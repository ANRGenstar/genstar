package spll.example;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;

import org.geotools.feature.SchemaException;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.opengis.referencing.operation.TransformException;

import core.io.GSExportFactory;
import core.io.GSImportFactory;
import core.io.exception.InvalidFileTypeException;
import core.io.geo.GeoGSFileType;
import core.io.geo.IGSGeofile;
import core.io.geo.RasterFile;
import core.io.geo.ShapeFile;
<<<<<<< Updated upstream
import core.io.survey.attribut.ASurveyAttribute;
import core.io.survey.attribut.value.AValue;
=======
import core.io.survey.entity.ASurveyEntity;
import core.io.survey.entity.attribut.ASurveyAttribute;
import core.io.survey.entity.attribut.value.ASurveyValue;
>>>>>>> Stashed changes
import core.metamodel.IPopulation;
import core.util.GSBasicStats;
import core.util.GSPerformanceUtil;
import gospl.GosplSPTemplate;
import gospl.algo.IDistributionInferenceAlgo;
import gospl.algo.IndependantHypothesisAlgo;
import gospl.algo.sampler.GosplBasicSampler;
import gospl.algo.sampler.ISampler;
import gospl.distribution.GosplDistributionFactory;
import gospl.distribution.exception.IllegalControlTotalException;
import gospl.distribution.exception.IllegalDistributionCreation;
import gospl.distribution.matrix.INDimensionalMatrix;
import gospl.distribution.matrix.coordinate.ACoordinate;
import gospl.generator.DistributionBasedGenerator;
import gospl.generator.ISyntheticGosplPopGenerator;
<<<<<<< Updated upstream
import gospl.metamodel.GosplPopulation;
=======
>>>>>>> Stashed changes
import spll.algo.ISPLRegressionAlgo;
import spll.algo.LMRegressionOLS;
import spll.algo.exception.IllegalRegressionException;
import spll.datamapper.ASPLMapperBuilder;
import spll.datamapper.SPLAreaMapperBuilder;
import spll.datamapper.SPLMapper;
import spll.datamapper.exception.GSMapperException;
import spll.datamapper.variable.SPLVariable;
import spll.popmapper.SPUniformLocalizer;
import spll.popmapper.normalizer.SPLUniformNormalizer;

public class TestLocalisation {

	
<<<<<<< Updated upstream
	public static void main(String[] args) {
=======
	private static IPopulation<ASurveyEntity, ASurveyAttribute, ASurveyValue> generatePopulation(int targetPopulation ) {
		// INPUT ARGS
		
		Path confFile = Paths.get("sample/Rouen/Rouen_insee_indiv/GSC_RouenIndividual.xml");
		
		// THE POPULATION TO BE GENERATED
		IPopulation<ASurveyEntity, ASurveyAttribute, ASurveyValue> population = null;

		// INSTANCIATE FACTORY
		GosplDistributionFactory df = null; 
		try {
			df = new GosplDistributionFactory(confFile);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		// RETRIEV INFORMATION FROM DATA IN FORM OF A SET OF JOINT DISTRIBUTIONS 
		try {
			df.buildDistributions();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (InvalidFileTypeException e) {
			e.printStackTrace();
		} 
>>>>>>> Stashed changes
		
		
		///////////////////////
		// PARAMETERS
		///////////////////////
		
<<<<<<< Updated upstream
		//target number of entities to create
		int targetPopulation = 10000; 
		
		//path to the configuration file for the population generation (GOSPL)
		String stringPathToXMLConfFile = "sample/Rouen/Rouen_insee_indiv/GSC_RouenIndividual.xml";
=======
		// so we collapse all distribution build from the data
		INDimensionalMatrix<ASurveyAttribute, ASurveyValue, Double> distribution = null;
		try {
			distribution = df.collapseDistributions();
		} catch (IllegalDistributionCreation e1) {
			e1.printStackTrace();
		} catch (IllegalControlTotalException e1) {
			e1.printStackTrace();
		}
		
		// BUILD THE SAMPLER WITH THE INFERENCE ALGORITHM
		IDistributionInferenceAlgo<ASurveyAttribute, ASurveyValue> distributionInfAlgo = new IndependantHypothesisAlgo(true);
		ISampler<ACoordinate<ASurveyAttribute, ASurveyValue>> sampler = null;
		try {
			sampler = distributionInfAlgo.inferDistributionSampler(distribution, new GosplBasicSampler());
		} catch (IllegalDistributionCreation e1) {
			e1.printStackTrace();
		}
>>>>>>> Stashed changes
		
		//path to the main census shapefile - the entities are generated at this level
		String stringPathToCensusShapefile = "sample/Rouen/Rouen_shp/Rouen_iris.shp";
		
		//path to the shapefile that define the geographical objects on which the entities should be located
		String stringPathToNestShapefile = "sample/Rouen/Rouen_shp/buildings.shp";
		
		//path to the file that will be used as support for the spatial regression (bring additional spatial data)
		String stringPathToLandUseGrid = "sample/Rouen/Rouen_raster/CLC12_D076_RGF_S.tif";
		
		//path to the csv file that contains data (population number) that should be added to the census shapefile
		String stringPathAdditionaryDataToCensusFile = "sample/Rouen/Rouen_insee_indiv/Rouen_iris.csv";
				
		//path to the result files
		String stringPathToRegressionGrid = "sample/Rouen/regression_grid.tif";
		String stringPathToPopulationShapefile = "sample/Rouen/population.shp";
		
<<<<<<< Updated upstream
		//name of the property that define the number of entities per census spatial areas.
		String stringOfNumberProperty = "P13_POP";
=======
		return population;
	}
	
	public static void main(String[] args) {
		int targetPopulation = 1000;
		IPopulation<ASurveyEntity, ASurveyAttribute, ASurveyValue> population = generatePopulation(targetPopulation);
>>>>>>> Stashed changes
		
		//name of the property that contains the id of the census spatial areas in the shapefile
		String stringOfCensusIdInShapefile = "CODE_IRIS";
		
		//name of the property that contains the id of the census spatial areas in the csv file (and population)
		String stringOfCensusIdInCSVfile = "IRIS";
		
		//name of the property that will by generated by the regression and that specifies the number of entities per regression areas
		String stringOfNumberAttribute = "Band_0";
		
		/////////////////////
		// GENERATE THE POPULATION (GOSPL)
		/////////////////////
		
		IPopulation population = generatePopulation(targetPopulation,stringPathToXMLConfFile);
				
		/////////////////////
		// IMPORT DATA FILES
		/////////////////////
		List<String> atts_buildings = Arrays.asList();
		core.util.GSPerformanceUtil gspu = new GSPerformanceUtil("Localisation of people in Rouen based on Iris population");
		ShapeFile sfAdmin = null;
		ShapeFile sfBuildings = null;
		
		try {
			//building shapefile
			sfBuildings = GSImportFactory.getShapeFile(stringPathToNestShapefile, atts_buildings);
			
			//Iris shapefile
			sfAdmin = GSImportFactory.getShapeFile(stringPathToCensusShapefile);
			
			//add from the csv file, the population attribute to the Iris shapefile
			List<String> att = new ArrayList<String>();
			att.add(stringOfNumberProperty);
			sfAdmin.addAttributes(new File(stringPathAdditionaryDataToCensusFile), ',', stringOfCensusIdInShapefile, stringOfCensusIdInCSVfile, att);
		} catch (IOException e) {
			e.printStackTrace();
		} catch (InvalidFileTypeException e) {
			e.printStackTrace();
		}
		
		
		//import the land-use file
		Collection<String> stringPathToAncilaryGeofiles = new ArrayList<>();
		stringPathToAncilaryGeofiles.add(stringPathToLandUseGrid);

		List<IGSGeofile> endogeneousVarFile = new ArrayList<>();
		for(String path : stringPathToAncilaryGeofiles){
			try {
				endogeneousVarFile.add(GSImportFactory.getGeofile(path));
			} catch (IllegalArgumentException | TransformException | IOException | InvalidFileTypeException e2) {
				e2.printStackTrace();
			}
		}
		gspu.sysoStempPerformance("Input files data import: done\n", "Main");

		
		//////////////////////////////////
		// SETUP MAIN CLASS FOR REGRESSION
		//////////////////////////////////
		
		// Choice have been made to regress from areal data count
		ISPLRegressionAlgo<SPLVariable, Double> regressionAlgo = new LMRegressionOLS();
		
		ASPLMapperBuilder<SPLVariable, Double> spllBuilder = new SPLAreaMapperBuilder(
				sfAdmin, stringOfNumberProperty, endogeneousVarFile, new ArrayList<>(),
				regressionAlgo);
		gspu.sysoStempPerformance("Setup MapperBuilder to proceed regression: done\n", "Main");
 
		// Setup main regressor class: SPLMapper
		SPLMapper<SPLVariable,Double> spl = null;
		boolean syso = false;
		try {
			spl = spllBuilder.buildMapper();
			if(syso){
				Map<SPLVariable, Double> regMap = spl.getRegression();
				gspu.sysoStempMessage("Regression parameter: \n"+Arrays.toString(regMap.entrySet().stream().map(e -> e.getKey()+" = "+e.getValue()+"\n").toArray()));
				gspu.sysoStempMessage("Intersect = "+spl.getIntercept());
			}
		} catch (IOException e1) {
			e1.printStackTrace();
		} catch (TransformException e1) {
			e1.printStackTrace();
		} catch (InterruptedException e1) {
			e1.printStackTrace();
		} catch (ExecutionException e1) {
			e1.printStackTrace();
		} catch (IllegalRegressionException e) {
			e.printStackTrace();
		}

		// ---------------------------------
		// Apply regression function to output
		// ---------------------------------
		
		// WARNING: not generic at all - or define 1st ancillary data file to be the one for output format
		RasterFile outputFormat = (RasterFile) endogeneousVarFile
				.stream().filter(file -> file.getGeoGSFileType().equals(GeoGSFileType.RASTER))
				.findFirst().get();
		spllBuilder.setNormalizer(new SPLUniformNormalizer(0, RasterFile.DEF_NODATA));
		float[][] pixelOutput = null;
		try { 
			pixelOutput = spllBuilder.buildOutput(outputFormat, false, true, new Double(targetPopulation));
		} catch (IOException e) {
			e.printStackTrace();
		} catch (IllegalRegressionException e) {
			e.printStackTrace();
		} catch (IndexOutOfBoundsException e1) {
			e1.printStackTrace();
		} catch (TransformException e1) {
			e1.printStackTrace();
		} catch (GSMapperException e) {
			e.printStackTrace();
		}
		
		List<Double> outList = GSBasicStats.transpose(pixelOutput);
		GSBasicStats<Double> bs = new GSBasicStats<>(outList, Arrays.asList(RasterFile.DEF_NODATA.doubleValue()));
		gspu.sysoStempMessage("\nStatistics on output:\n"+bs.getStatReport());
		
<<<<<<< Updated upstream
		//save the result of the regression into a grid file
		IGSGeofile outputFile = null;
		try {
			ReferencedEnvelope env = new ReferencedEnvelope( endogeneousVarFile.get(0).getEnvelope());
			outputFile = GSExportFactory.createGeotiffFile(new File(stringPathToRegressionGrid), pixelOutput, env,outputFormat.getCoordRefSystem());
=======
		try {
			ReferencedEnvelope env = new ReferencedEnvelope( endogeneousVarFile.get(0).getEnvelope());
			GSExportFactory.createGeotiffFile(new File("sample/Rouen/result.tif"), pixelOutput, env,outputFormat.getCoordRefSystem());
>>>>>>> Stashed changes
		} catch (IllegalArgumentException e1) {
			e1.printStackTrace();
		} catch (IOException e1) {
			e1.printStackTrace();
		} catch (TransformException e1) {
			e1.printStackTrace();
		}
		 
		
		///////////////////////
		// MATCH TO POPULATION
		///////////////////////
<<<<<<< Updated upstream
		
 		SPUniformLocalizer localizer = new SPUniformLocalizer(sfBuildings);
 		
 		// use of the regression grid
 		localizer.setEntityNbAreas(outputFile, stringOfNumberAttribute);
=======

 		SPUniformLocalizer localizer = new SPUniformLocalizer(population, null/*sfAdmin*/, sfBuildings, null, "IRIS", "CODE_IRIS");
>>>>>>> Stashed changes
		
 		// use of the IRIS attribute of the population
 		localizer.setMatch(sfAdmin, stringOfCensusIdInCSVfile, stringOfCensusIdInShapefile);
 		
 		//localize the population
 		localizer.localisePopulation(population);
 		
		/////////////////////////////////////////
		// SAVE THE POPULATION INTO A SHAPEFILE
		////////////////////////////////////////

		try {
			GSExportFactory.createShapeFile(new File(stringPathToPopulationShapefile), population, outputFormat.getCoordRefSystem());
		} catch (IOException | SchemaException e) {
			e.printStackTrace();
		}
	}
	
	private static GosplPopulation generatePopulation(int targetPopulation, String xmlFilePath ) {
		// INPUT ARGS
		
		Path confFile = Paths.get(xmlFilePath);
		
		// THE POPULATION TO BE GENERATED
		GosplPopulation population = null;

		// INSTANCIATE FACTORY
		GosplDistributionFactory df = null; 
		try {
			df = new GosplDistributionFactory(confFile);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		// RETRIEV INFORMATION FROM DATA IN FORM OF A SET OF JOINT DISTRIBUTIONS 
		try {
			df.buildDistributions();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (InvalidFileTypeException e) {
			e.printStackTrace();
		} 
		
		// TRANSPOSE SAMPLES INTO IPOPULATION
		try {
			df.buildSamples();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (InvalidFileTypeException e) {
			e.printStackTrace();
		}
		
		// HERE IS A CHOICE TO MAKE BASED ON THE TYPE OF GENERATOR WE WANT:
		// Choice is made here to use distribution based generator
		
		// so we collapse all distribution build from the data
		INDimensionalMatrix<ASurveyAttribute, AValue, Double> distribution = null;
		try {
			distribution = df.collapseDistributions();
		} catch (IllegalDistributionCreation e1) {
			e1.printStackTrace();
		} catch (IllegalControlTotalException e1) {
			e1.printStackTrace();
		}
		
		// BUILD THE SAMPLER WITH THE INFERENCE ALGORITHM
		IDistributionInferenceAlgo distributionInfAlgo = new IndependantHypothesisAlgo();
		ISampler<ACoordinate<ASurveyAttribute, AValue>> sampler = null;
		try {
			sampler = distributionInfAlgo.inferDistributionSampler(distribution, new GosplBasicSampler());
		} catch (IllegalDistributionCreation e1) {
			e1.printStackTrace();
		}
		
		
		GSPerformanceUtil gspu = new GSPerformanceUtil("Start generating synthetic population of size "+targetPopulation);
		
		// BUILD THE GENERATOR
		ISyntheticGosplPopGenerator ispGenerator = new DistributionBasedGenerator(sampler);
		
		// BUILD THE POPULATION
		try {
			population = ispGenerator.generate(targetPopulation);
			gspu.sysoStempPerformance("End generating synthetic population: elapse time", GosplSPTemplate.class.getName());
		} catch (NumberFormatException e) {
			e.printStackTrace();
		}
		
		return population;
	}
	

}
