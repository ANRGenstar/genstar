package gospl.distribution.util;

import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

<<<<<<< Updated upstream
import core.io.survey.entity.attribut.AGenstarAttribute;
import core.io.survey.entity.attribut.value.AGenstarValue;
=======
import core.io.survey.entity.attribut.ASurveyAttribute;
import core.io.survey.entity.attribut.value.ASurveyValue;
>>>>>>> Stashed changes
import gospl.distribution.matrix.AFullNDimensionalMatrix;
import gospl.distribution.matrix.coordinate.ACoordinate;
import gospl.distribution.matrix.coordinate.GosplCoordinate;

<<<<<<< Updated upstream
public class GosplBasicDistribution implements Map<ACoordinate<AGenstarAttribute, AGenstarValue>, Double> {

	private final Map<ACoordinate<AGenstarAttribute, AGenstarValue>, Double> innermap; 

	public GosplBasicDistribution(Map<Set<AGenstarValue>, Double> sampleDistribution) {
=======
public class GosplBasicDistribution implements Map<ACoordinate<ASurveyAttribute, ASurveyValue>, Double> {

	private final Map<ACoordinate<ASurveyAttribute, ASurveyValue>, Double> innermap; 

	public GosplBasicDistribution(Map<Set<ASurveyValue>, Double> sampleDistribution) {
>>>>>>> Stashed changes
		if(sampleDistribution.isEmpty())
			throw new IllegalArgumentException("Sample distribution cannot be empty");
		innermap = sampleDistribution.entrySet().parallelStream()
				.sorted(Map.Entry.comparingByValue())
				.collect(Collectors.toMap(e -> new GosplCoordinate(e.getKey()), e -> e.getValue(), 
						(e1, e2) -> e1, LinkedHashMap::new));
	}

	public GosplBasicDistribution(AFullNDimensionalMatrix<Double> distribution) {
		innermap = distribution.getMatrix().entrySet().stream()
				.sorted(Map.Entry.comparingByValue())
				.collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue().getValue(), 
						(e1, e2) -> e1, LinkedHashMap::new));
	}

	@Override
	public int size() {
		return innermap.size();
	}

	@Override
	public boolean isEmpty() {
		return innermap.isEmpty();
	}

	@Override
	public boolean containsKey(Object key) {
		return innermap.containsKey(key);
	}

	@Override
	public boolean containsValue(Object value) {
		return innermap.containsValue(value);
	}

	@Override
	public Double get(Object key) {
		return innermap.get(key);
	}

	@Override
<<<<<<< Updated upstream
	public Double put(ACoordinate<AGenstarAttribute, AGenstarValue> key, Double value) {
=======
	public Double put(ACoordinate<ASurveyAttribute, ASurveyValue> key, Double value) {
>>>>>>> Stashed changes
		return innermap.put(key, value);
	}

	@Override
	public Double remove(Object key) {
		return innermap.remove(key);
	}

	@Override
<<<<<<< Updated upstream
	public void putAll(Map<? extends ACoordinate<AGenstarAttribute, AGenstarValue>, ? extends Double> m) {
=======
	public void putAll(Map<? extends ACoordinate<ASurveyAttribute, ASurveyValue>, ? extends Double> m) {
>>>>>>> Stashed changes
		innermap.putAll(m);
	}

	@Override
	public void clear() {
		innermap.clear();
	}

	@Override
<<<<<<< Updated upstream
	public Set<ACoordinate<AGenstarAttribute, AGenstarValue>> keySet() {
=======
	public Set<ACoordinate<ASurveyAttribute, ASurveyValue>> keySet() {
>>>>>>> Stashed changes
		return innermap.keySet();
	}

	@Override
	public Collection<Double> values() {
		return innermap.values();
	}

	@Override
<<<<<<< Updated upstream
	public Set<java.util.Map.Entry<ACoordinate<AGenstarAttribute, AGenstarValue>, Double>> entrySet() {
=======
	public Set<java.util.Map.Entry<ACoordinate<ASurveyAttribute, ASurveyValue>, Double>> entrySet() {
>>>>>>> Stashed changes
		return innermap.entrySet();
	}
	
	@Override
	public String toString() {
		StringBuffer sb = new StringBuffer(); 
		sb.append("[");
		sb.append(GosplBasicDistribution.class.getSimpleName());
		sb.append("] ");
		sb.append(innermap.entrySet().parallelStream().map(sc -> sc.getKey().getDimensions()).collect(Collectors.toSet()));
		sb.append(" card=");
		sb.append(innermap.size());
		return sb.toString();
	}

}
